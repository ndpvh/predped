# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Transform trace to comprehensive data.frame
#' 
#' Rcpp alternative for the \code{\link[predped]{unpack_trace}} function.
#'
#' This function will take a trace and return a data.frame containing all 
#' information contained within a typical time-series (cfr. 
#' \code{\link[predped]{time_series}}) and with all the input that should be 
#' provided to the utility functions. This is therefore the primary function to 
#' use if you want to go from a trace to a data.frame that can be used in 
#' M4MA-based estimations.
#' 
#' @param trace List of objects of the \code{\link[predped]{state-class}}
#' @param velocities Numeric matrix containing the change in speed for an agent
#' whenever they move to the respective cell of this matrix. Is used to create 
#' the cell positions that the agent might move to, as performed through 
#' \code{\link[m4ma]{c_vd_rcpp}}. Currently limited to having 11 rows (direction) 
#' and 3 columns (speed). Defaults to a matrix in which the columns contain 
#' \code{1.5} (acceleration), \code{1}, and \code{0.5}.
#' @param orientations Numeric matrix containing the change in direction for an 
#' agent whenever they move to the respective cell of this matrix. Is used to 
#' create the cell positions that the agent might move to, as performed through
#' \code{\link[m4ma]{c_vd_rcpp}}. Currently limited to having 11 rows (direction)
#' and 3 columns (speed). Defaults to a matrix in which the rows contain 
#' \code{72.5}, \code{50}, \code{32.5}, \code{20}, \code{10}, code{0}, \code{350}, 
#' \code{340}, \code{327.5}, \code{310}, \code{287.5} (note that the larger 
#' angles are actually the negative symmetric versions of the smaller angles).
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the time between each iteration. Defaults 
#' to \code{0.5} (the same as in \code{\link[predped]{simulate,predped-method}}).
#' 
#' @examples
#' # This is my example
#'
#' @rdname unpack_trace_rcpp
#' 
#' @export
unpack_trace <- function(x, velocities, orientations, stay_stopped = TRUE, time_step = 0.5) {
    invisible(.Call('_predped_unpack_trace', PACKAGE = 'predped', x, velocities, orientations, stay_stopped, time_step))
}

unique <- function(x) {
    .Call('_predped_unique', PACKAGE = 'predped', x)
}

#' Compute the min-log-likelihood
#' 
#' Rcpp alternative to \code{\link[predped]{mll}}. Be wary: This version does 
#' not automatically add the motion variables to the data if not present in 
#' the data, nor does it do any of the other preprocessing. It is therefore 
#' better not used as an alternative to the R version, but rather as an 
#' extension of it (as done automatically in predped). 
#'
#' @param data Data.frame containing at least "id", "time", "x", "y", "goal_x",
#' "goal_y", and "goal_id". If it does not have the utility variables yet, these
#' will add them to the data.frame.
#' @param parameters Numeric vector or matrix containing the parameters to be 
#' used. Should be specified in the same order as specified in 
#' \code{"parameter_names"}. If a matrix, each row should contain parameters to 
#' be estimated for each instance of "id" separately.
#' @param parameter_names Character vector containing the parameters that you 
#' want to estimate. Defaults to all parameters defined in
#' \code{\link[predped]{params_from_csv}}. Whenever not all parameters are used,
#' the excluded parameters are assumed to have a value of 0.
#' @param transform Logical denoting whether to transform the provided parameters
#' from the real axis to the bounded scales imposed on the parameters within 
#' \code{predped}. Defaults to \code{TRUE}.
#' @param bounds Matrix containing the lower and upper bounds of the parameters
#' in its first and second column respectively. Additionally, rownames should 
#' denote for which parameter a certain pair represents the bounds. Only used 
#' when \code{transform = TRUE}. Defaults to the default bounds of \code{predped}.
#' @param ... Additional arguments passed on to \code{\link[predped]{add_motion_variables}}.
#' In a typical estimation situation, these motion variables should already be 
#' in \code{data}.
#' 
#' @return Min-log-likelihood per person in the dataset.
#' 
#' @export 
mll_rcpp <- function(data, parameters, parameter_names, ids) {
    .Call('_predped_mll_rcpp', PACKAGE = 'predped', data, parameters, parameter_names, ids)
}

psUtility <- function(a_preferred_speed, b_preferred_speed, preferred_speed, slowing_time, current_speed, goal_distance) {
    .Call('_predped_psUtility', PACKAGE = 'predped', a_preferred_speed, b_preferred_speed, preferred_speed, slowing_time, current_speed, goal_distance)
}

gaUtility <- function(b_goal_direction, a_goal_direction, goal_angles) {
    .Call('_predped_gaUtility', PACKAGE = 'predped', b_goal_direction, a_goal_direction, goal_angles)
}

caUtility <- function(b_current_direction, a_current_direction, blr_current_direction) {
    .Call('_predped_caUtility', PACKAGE = 'predped', b_current_direction, a_current_direction, blr_current_direction)
}

idUtility <- function(b_current_direction, d_current_direction, a_current_direction, id_ingroup, id_check, id_distance, impossible_utility) {
    .Call('_predped_idUtility', PACKAGE = 'predped', b_current_direction, d_current_direction, a_current_direction, id_ingroup, id_check, id_distance, impossible_utility)
}

baUtility <- function(a_blocked, b_blocked, ba_angle, cone_id) {
    .Call('_predped_baUtility', PACKAGE = 'predped', a_blocked, b_blocked, ba_angle, cone_id)
}

flUtility <- function(a_leader, b_leader, d_leader, leaders, distances) {
    .Call('_predped_flUtility', PACKAGE = 'predped', a_leader, b_leader, d_leader, leaders, distances)
}

wbUtility <- function(a_buddy, b_buddy, buddies, distances) {
    .Call('_predped_wbUtility', PACKAGE = 'predped', a_buddy, b_buddy, buddies, distances)
}

destinationAngle <- function(orientation, agent_position, goal_position) {
    .Call('_predped_destinationAngle', PACKAGE = 'predped', orientation, agent_position, goal_position)
}

predClose <- function(agent_idx, agent_position, orientation, others_position, radius, centers, predicted_positions, objects) {
    .Call('_predped_predClose', PACKAGE = 'predped', agent_idx, agent_position, orientation, others_position, radius, centers, predicted_positions, objects)
}

blockedAngle <- function(agent_position, orientation, speed, predictions_minus_agent, radii, objects) {
    .Call('_predped_blockedAngle', PACKAGE = 'predped', agent_position, orientation, speed, predictions_minus_agent, radii, objects)
}

#' Predict agents' movement
#' 
#' Rcpp alternative of \code{\link[predped]{predict_movement}}.
#'
#' Uses the agents' current speed and orientation to determine where the agent 
#' might end up in the next step, assuming that they do not change direction or 
#' speed. This information is used by other agents to determine where (not) to 
#' go to avoid collisions.
#' 
#' @param agent Object of the \code{\link[predped]{agent-class}}.
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the number of seconds each discrete step in
#' time should mimic. Defaults to \code{0.5}, or half a second.
#' 
#' @return Numeric matrix containing the predicted positions all agents if 
#' they all maintain their speed and direction.
#' 
#' @seealso 
#' \code{\link[predped]{create_agent_specifications}},
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}}
#' 
#' @rdname predict_movement_rcpp
#' 
#' @export
predict_movement_rcpp <- function(agent, stay_stopped = TRUE, time_step = 0.5) {
    .Call('_predped_predict_movement_rcpp', PACKAGE = 'predped', agent, stay_stopped, time_step)
}

#' Create agent specifications
#' 
#' Rcpp alternative to the \code{\link[predped]{create_agent_specifications}} 
#' function.
#'
#' This list translates the information available in the \code{agents} slot of
#' the current status of the \code{\link[predped]{state-class}} to a list 
#' with all this information in numeric vectors or matrices instead of inside 
#' objects. Allows for a translation from the object-oriented way of doing things
#' in \code{predped} to the vectorized way of doing things in \code{m4ma}.
#'
#' @param agent Object of the \code{\link[predped]{agent-class}}.
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the number of seconds each discrete step in
#' time should mimic. Defaults to \code{0.5}, or half a second.
#' 
#' @return List containing all information of all agents within the current 
#' state.
#' 
#' @seealso 
#' \code{\link[predped]{create_agent_specifications}},
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}}
#' 
#' @rdname create_agent_specifications_rcpp
#' 
#' @export
create_agent_specifications_rcpp <- function(agent_list, stay_stopped = TRUE, time_step = 0.5) {
    .Call('_predped_create_agent_specifications_rcpp', PACKAGE = 'predped', agent_list, stay_stopped, time_step)
}

#' Distances to group centroid
#'
#' Rcpp version of \code{\link[predped]{distance_group_centroid}}. 
#' 
#' Compute the distance of a given agent to the group centroid. This group 
#' centroid is computed as a summary statistic of the predicted x- and y-
#' coordinates of all pedestrians belonging to the same group as the agent. The 
#' summary statistic of choice should be one of mean-tendency, but can be 
#' specified by the user through the argument \code{fx}.
#' 
#' Note that this function has been defined to be in line with the \code{m4ma}
#' utility functions.
#'
#' @param p_pred Numeric matrix with shape N x 2 containing predicted positions
#' of all pedestrians that belong to the social group of the agent.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param nped Numeric integer indicating number of people in pedestrian `n`'s social group. 
#' @param fx Function used to find the group centroid. Defaults to \code{mean}
#'
#' @return Numeric vector containing the distance from each cell in the `center`
#' to the group centroid. If not other agents belong to the same group as the 
#' agent, returns \code{NULL}.
#' 
#' @seealso 
#' \code{\link[predped]{gc_utility}},
#' \code{\link[predped]{utility}}
#' 
#' @rdname distance_group_centroid_rcpp
#'
#' @export 
distance_group_centroid_rcpp <- function(predictions, centers, number_agents) {
    .Call('_predped_distance_group_centroid_rcpp', PACKAGE = 'predped', predictions, centers, number_agents)
}

#' Angle between agent and group members
#' 
#' Finds the angle at which the group members are located compared to the agent.
#' Uses the predicted positions of the group members for this.
#'
#' @param agent_idx Numeric denoting the position of the agent in the prediction 
#' matrix \code{p_pred}.
#' @param agent_group Numeric vector with the group membership of all 
#' pedestrians.
#' @param position Numeric vector denoting the current position of the agent.
#' @param orientation Numeric denoting the current orientation of the agent.
#' @param p_pred Numeric matrix with shape N x 2 containing predicted positions
#' of all pedestrians that belong to the social group of the agent.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param any_member Logical denoting whether to consider the angles of all 
#' group members (\code{TRUE}) -- effectively saying that it doesn't matter 
#' which group member the agent can see, as long as they can see one -- or 
#' whether to only consider the nearest group member (\code{FALSE}). Defaults 
#' to \code{TRUE}.
#'
#' @return Numeric vector containing the relative angle of the group member(s)
#' compared to the orientation of the agent within a given cell in \code{centers}.
#' 
#' @seealso 
#' \code{\link[predped]{utility}}
#' \code{\link[predped]{vf_utility_continuous}}
#' \code{\link[predped]{vf_utility_discrete}}
#' 
#' @rdname get_angles_rcpp
#' 
#' @export 
get_angles_rcpp <- function(agent_idx, agent_groups, position, orientation, predictions, centers, any_member = TRUE) {
    .Call('_predped_get_angles_rcpp', PACKAGE = 'predped', agent_idx, agent_groups, position, orientation, predictions, centers, any_member)
}

#' Compute utility variables
#' 
#' Rcpp version of the \code{\link[predped]{compute_utility_variables}} function.
#' 
#' @param object Object of the \code{\link[predped]{agent-class}}.
#' @param state Object of the \code{\link[predped]{state-class}}.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param agent_specifications List created by the 
#' \code{\link[predped]{create_agent_specifications}} function. Contains all 
#' information of all agents within the current \code{state} and allows for the
#' communication between the \code{predped} simulation functions and the 
#' \code{m4ma} utility functions.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param check Logical matrix of dimensions 11 x 3 denoting whether an agent 
#' can move to a given cell (\code{TRUE}) or not (\code{FALSE}).
#' 
#' @return Data.frame containing all of the needed variables to be able to 
#' compute the values of the utility functions.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{update_position}},
#' \code{\link[predped]{update}}
#' 
#' @rdname compute_utility_variables_rcpp
#' 
#' @export 
compute_utility_variables_rcpp <- function(agent, state, background, agent_specifications, centers, check) {
    .Call('_predped_compute_utility_variables_rcpp', PACKAGE = 'predped', agent, state, background, agent_specifications, centers, check)
}

#' Group centroid utility
#'
#' Rcpp alternative for the group centroid utility function. 
#' 
#' @param a_gc Numeric denoting the power to which to take the utility.
#' @param b_gc Numeric denoting the slope of the utility function.
#' @param radius Numeric denoting the radius of the agent.
#' @param cell_dist Numeric vector denoting the distance of each cell in the 
#' \code{centers} to the predicted group centroid.
#' @param stop_utility Numeric denoting the utility of stopping. Is used to 
#' ensure the agents do not freeze when they are too far away from each other. 
#' @param nped Numeric denoting the number of ingroup members. 
#' 
#' @return Numeric vector containing the group-centroid-related utility for each 
#' cell. 
#' 
#' @seealso 
#' \code{\link[predped]{distance_group_centroid}},
#' \code{\link[predped]{params_from_csv}},
#' \code{\link[predped]{utility}}
#' 
#' @rdname gc_utility_rcpp
#' 
#' @export
gc_utility_rcpp <- function(a_group_centroid, b_group_centroid, radius, cell_distances, stop_utility, nped) {
    .Call('_predped_gc_utility_rcpp', PACKAGE = 'predped', a_group_centroid, b_group_centroid, radius, cell_distances, stop_utility, nped)
}

#' Discrete visual field utility
#' 
#' Rcpp alternative to the \code{vf_utility_discrete} function.
#' 
#' The idea of this utility function is that it doesn't matter at which angle 
#' you see a group member within the visual field, as long as you see them. 
#' This translates to a discrete added disutility whenever the group member 
#' falls inside the non-visual zone behind the agent.
#' 
#' @param b_vf Numeric denoting the slope of the utility function. 
#' @param rel_angles Numeric vector containing the relative angle from each cell 
#' center to the predicted positions of the group members. Typically output of 
#' \code{\link[predped]{get_angle}}. 
#' 
#' @return Numeric vector containing the utility attributed to keeping the 
#' group members within your visual field. Returns 0's if the agent does not 
#' have any additional group members.
#' 
#' @seealso 
#' \code{\link[predped]{get_angles}},
#' \code{\link[predped]{utility}},
#' \code{\link[predped]{vf_utility_continuous}}
#' 
#' @rdname vf_utility_rcpp
#' 
#' @export
vf_utility_rcpp <- function(b_visual_field, relative_angles) {
    .Call('_predped_vf_utility_rcpp', PACKAGE = 'predped', b_visual_field, relative_angles)
}

#' Utility
#'
#' This function is the Rcpp equivalent of \code{\link[predped]{utility}}. It
#' takes in a dataframe containing all of the relevant values for computing the
#' utility, as well as a dataframe containing the parameters. Heavily depends 
#' on the \code{m4ma} package.
#' 
#' @param object Dataframe containing all of the needed information to compute 
#' the utilities. Typically output of the 
#' \code{\link[predped]{compute_utility_variables}} function.
#' @param parameters Dataframe containing the parameters of the agent. Should 
#' conform to the naming conventions mentioned in 
#' \code{\link[predped]{params_from_csv}}.
#' 
#' @return Numeric vector denoting the (dis)utility of moving to each of the 
#' potential cells.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{utility,agent-method}},
#' \code{\link[predped]{compute_utility_variables}},
#' \code{\link[predped]{params_from_csv}},
#' \code{\link[predped]{update_position}}
#' 
#' @rdname utility_rcpp
#' 
utility_rcpp <- function(data, parameters) {
    .Call('_predped_utility_rcpp', PACKAGE = 'predped', data, parameters)
}

#' Utility
#'
#' This function is the Rcpp equivalent of \code{\link[predped]{utility}}. 
#' This function uses the operational-level utility functions to compute the 
#' utility of moving to any given potential cell in \code{centers}. Here, we 
#' assume that none of the utility variables (i.e., the variables that serve as 
#' input to the utility functions) is precomputed, so that it will first compute
#' their values. This input is then provided to 
#' \code{\link[predped]{utility,data.frame-method}} for the actual computation 
#' of the utility.
#' 
#' @param object Object of the \code{\link[predped]{agent-class}}.
#' @param state Object of the \code{\link[predped]{state-class}}.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param agent_specifications List created by the 
#' \code{\link[predped]{create_agent_specifications}} function. Contains all 
#' information of all agents within the current \code{state} and allows for the
#' communication between the \code{predped} simulation functions and the 
#' \code{m4ma} utility functions.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param check Logical matrix of dimensions 11 x 3 denoting whether an agent 
#' can move to a given cell (\code{TRUE}) or not (\code{FALSE}).
#' @param cpp Logical denoting whether to use the Rcpp version of the function
#' (\code{TRUE}) or the R version (\code{FALSE}). Defaults to \code{TRUE}.
#' 
#' @return Numeric vector denoting the (dis)utility of moving to each of the 
#' cells in \code{centers}.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{utility,data.frame-method}},
#' \code{\link[predped]{compute_utility_variables}},
#' \code{\link[predped]{update_position}}
#' 
#' @rdname utility_agent_rcpp
#' 
#' @export
utility_agent_rcpp <- function(agent, state, background, agent_specifications, centers, check) {
    .Call('_predped_utility_agent_rcpp', PACKAGE = 'predped', agent, state, background, agent_specifications, centers, check)
}

